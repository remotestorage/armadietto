#!/usr/bin/env node

const http = require('http');
const fs = require("fs");
const path = require("path");
const {ArgumentParser} = require("argparse");
const {configureLogger, getLogger} = require("../lib/logger");
const process = require("process");

/** Command-line arguments and configuration loading */

const args = parseArgs();
let conf = {};

if (args.exampleConf) {
  console.info(fs.readFileSync(path.join(__dirname, '/conf.example.json'), 'utf8'));
  return -1;
}

try {
  conf = JSON.parse(fs.readFileSync(args.conf, 'utf8'));
} catch (err) {
  console.error(`Unable to load config file “${args.conf}”:`, err);
  return -2;
}

/** Configures application */

configureLogger(conf.logging);

conf.basePath ||= '';
if (conf.basePath && !conf.basePath.startsWith('/')) { conf.basePath = '/' + conf.basePath; }
process.env.basePath = conf.basePath;

const app = require('../lib/app');   // process.env.basePath must have been set previously
const S3 = require("../lib/streaming_stores/S3");

const port = normalizePort( process.env.PORT || conf.http?.port || '8000');
app.set('port', port);

app.set('forceSSL', Boolean(conf.https?.force));
if (conf.http?.port && conf.https?.port) {
  app.set('httpsPort', parseInt(conf.https?.port));   // only for redirecting to HTTPS
}

// If the environment variables aren't set, storage uses a shared public account on play.min.io!
app.set('streaming store', new S3(process.env.S3_ENDPOINT,
  process.env.S3_ACCESS_KEY, process.env.S3_SECRET_KEY));


app.locals.title = "Modular Armadietto";
app.locals.basePath = conf.basePath;
// rendering should set locals.host: getHost(req)
app.locals.host = conf.http?.host + (port ? ':' + port : '');
app.locals.signup = conf.allow_signup;

/** Creates HTTP server. */

const server = http.createServer(app);

/** Listens on provided port, on all network interfaces. */

server.listen(port);
server.on('error', onError);
server.on('listening', onListening);

/** Event listener for HTTP server "error" event. */
function onError(error) {
  if (error.syscall !== 'listen') {
    throw error;
  }

  const bind = typeof port === 'string'
    ? 'Pipe ' + port
    : 'Port ' + port;

  // handle specific listen errors with friendly messages
  switch (error.code) {
    case 'EACCES':
      getLogger().crit(bind + ' requires elevated privileges');
      process.exit(1);
      break;
    case 'EADDRINUSE':
      getLogger().crit(bind + ' is already in use');
      process.exit(1);
      break;
    default:
      throw error;
  }
}

/** Event listener for HTTP server "listening" event. */
function onListening() {
  getLogger().notice(`Accepting remoteStorage connections: http://${app.locals.host}/${app.locals.basePath} ${(conf.https?.port) || ''}`);
}

/** Adds listeners for shutdown and serious problems */

// These are the happy paths for shutdown.
process.on('SIGINT', stop.bind(this, 'SIGINT'));
process.on('SIGTERM', stop.bind(this, 'SIGTERM'));

function stop(signal) {
  getLogger().debug(`${signal} signal received: closing HTTP server`);
  server.close(() => {
    getLogger().notice('No longer accepting remoteStorage connections');
  });
}

// Without these listeners, these events would not be logged, only sent to stdout or stderr.
process.on('uncaughtExceptionMonitor', (err, origin) => {
  getLogger().crit(`${origin} ${err}`);
});

process.on('warning', (warning) => {
  getLogger().warning(`${warning.name} ${warning.message} ${warning.stack}`);
});

process.on('multipleResolves', (type, promise, reason) => {
  getLogger().debug(`multipleResolves ${type} “${reason}”`);
});


/** parses command-line arguments */
function parseArgs () {
  const version = require(path.join(__dirname, '/../package.json')).version;
  const parser = new ArgumentParser({
    add_help: true,
    description: 'NodeJS remoteStorage server / ' + version
  });

  parser.add_argument('-c', '--conf', {
    help: 'Path to configuration'
  });

  parser.add_argument('-e', '--exampleConf', {
    help: 'Print configuration example',
    action: 'store_true'
  });

  return parser.parse_args();
}

/** Normalizes a port into a number, string, or false. */
function normalizePort(val) {
  const port = parseInt(val, 10);

  if (isNaN(port)) {
    // named pipe
    return val;
  }

  if (port >= 0) {
    // port number
    return port;
  }

  return false;
}
